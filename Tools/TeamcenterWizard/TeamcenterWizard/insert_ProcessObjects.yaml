InternalClassType: Method
Coordinate3D: [2,-25,0]
Name: insert_ProcessObjects
Origin: 3a2981cf-66d0-4972-a43b-efb18f2f379e
Program: |+1
 /*_______________________________________________________________________________
 
 Method Tasks:
 -- builds the model from Process_Data for processes w/o resource assignment, 
    inserts ProcessBB simulation objects, 
 _________________________________________________________________________________
 Parameters	: none
 			  
 ReturnValues: none
 
 Called By	: Generate
 Calls		: write_CreatedObjects, fill_OpList, makeValidObjectName
 
 Author		: Ralph Bauknecht
 Date		: 24.10.2018
 _________________________________________________________________________________
 History: 
 Date		Author	Description
 19.02..2021	RBA		Bugfix: new (unused) paramenter prodList for call of fill_OpList
 _________________________________________________________________________________*/
 
 var workareaTable : object := Process_Data
 var	tm, tmUp : real[4,4] -- transformation matrix from TC is converted to 4x4 matrix
 var HierarchyList : table[object, integer]
 var level : integer -- remember the level to build hierarchies and to assign graphics
 var station : object
 var insertPos : integer[2]
 -- opList : description, procTime, used parts, variants, ...
 var opList : table[string, time, string, string, string]
 -- prodList : part ID, part name, quantity
 var prodList : table[string, string, integer]
 
 opList.create
 prodList.create
 
 HierarchyList.create
 HierarchyList.writeRow(1, 1, Model_Root, -1) -- start building the model in root
 
 insertPos[1] := -58
 insertPos[2] := 4
 
 var i := 1
 while i <= workareatable.ydim
 	
 	level := workareatable["Level", i] -- level for actual object
 
 	-- manage hierarchy levels
 	if level <= HierarchyList[2, HierarchyList.yDim] -- if level for next object is not > actual building level
 		repeat -- delete all levels >= next object
 			HierarchyList.cutRow(HierarchyList.yDim)
 		until HierarchyList[2, HierarchyList.yDim] < level
 	end
 		
 	if (workareatable["Level",i] = Build_ProcessLevelNo OR (Build_ProcessLevelNo = -1 AND workareatable["PlantSimClass",i] = "Value")) AND workareatable["UsedResources",i] = VOID -- relevant process w/o BOE assignment
 		
 		if Build_ProcessLevelNo = -1 AND workareatable["PlantSimClass",i] = "Value" -- this is a "value stream" process object
 			station := rootfolder.ResourcePool.ProcessVS.derive(HierarchyList[1, HierarchyList.yDim]) -- create new simulation object
 			station.name :=  "ProcessVS" + "_" + MakeValidObjectName(workareatable["UniqueID", i])
 		else -- this is a process blackbox object
 			station := rootfolder.ResourcePool.ProcessBB.derive(HierarchyList[1, HierarchyList.yDim]) -- create new simulation object
 			station.name :=  "ProcessBB" + "_" + MakeValidObjectName(workareatable["UniqueID", i])
 		end
 		
 		-- pass parameter from TC to the object
 		station.label := workareatable["Name", i]
 		station.createAttr("AutoGenerated", "Boolean")
 		station.AutoGenerated := true
 		station.createAttr("PlantSimClass", "String")
 		station.PlantSimClass := Station.class.Name -- ProcessBB or ProcessVS
 		station.createAttr("Level", "integer")
 		station.Level := workareatable["Level", i]
 
 		-- set time data
 		var children : string := workareatable["ChildrenIDs", i] -- get all children of the process		
 		if children /= ""  -- process has children (operations with the time setting)
 			opList.delete
 			prodList.delete
 			fill_OpList(splitString(children, " "), opList, prodList) -- get all operations/subprocesses of the process with times, parts and variant data
 			
 			-- transfer data to Station object in Model
 			station.OperationTable.delete
 			station.OperationTable.insertList(1, 1, opList.copy({1,1}..{*,*}))
 			-- set formula that uses the operation table
 			station.ProcTime.Type := "Formula" -- set use formula
 			if station.internalClassName = "Network"
 				station.ProcTime.Formula := "getProcTime" -- set formula method
 			else
 				station.ProcTime.Formula := "self.getProcTime" -- set formula method as attribute
 			end
 				
 		else -- the process itself has the (accumulated) time
 			station.ProcTime.Type := "Const" -- set constant time
 			station.ProcTime := workareatable["Time", i] -- set time
 		end
 			
 		if Process_Data["Num_Workers", i] /= 0
 			station.NumWorker := Process_Data["Num_Workers", i] -- set no of workers at station
 		end
 		if Process_Data["Availability", i] /= 0
 			station.Availability := Process_Data["Availability", i] -- set Availability
 		end
 		if Process_Data["MTTR", i] /= 0
 			station.MTTR := Process_Data["MTTR", i] -- set MTTR
 		end
 /*		if Process_Data["Capacity", i] /= 0
 			Capacity := Process_Data["Capacity", i] -- TODO: use ParallelStation as ProcessBB and basic object in ProcessVS
 		end*/
 
 		insertPos[1] += 8
 		if insertPos[1] >= 50
 			insertPos[1] := -50
 			insertPos[2] -= 12
 		end
 		
 		tm := make4x4Array(makeArray(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, insertPos[1], insertPos[2], 0.0, 1.0))
 			
 		-- insert station info to Created_Objects table
 		write_CreatedObjects(station, tm[1,4], tm[2,4], tm[3,4], i, workareaTable)
 			
 		-- Set position and rotation for object (rotation around z-axis)
 		station._3D.TransformationMatrix  := tm
 							
 	end
 
 	i += 1
 
 end -- end while loop, covering the complete import table...
RandomSeed: 1073814187
UUID: b311bf4b-bcfa-44ae-8160-facfc108218f
